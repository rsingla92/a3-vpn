"""This module contains an implementation of the Deffie-Hellman 
Key Exchange Protocol.

Functions:
def gen_public_transport(encrypt_protocol=False, long_term_key=0)
-- used to generate local data, some of which should be sent as the transport data
gen_session_key(inc_pub_transport, local_exponent, encrypt_protocol=False, long_term_key=0)
-- used with the incoming transport data to generate a session key, only known
        locally, and to the computer that sent the transport data
"""
from xmlrpc import server
debug = False

import random
import aes
import connector

PUB_TRANSPORT_IDX = 0
LOC_EXPONENT_IDX = 1

#public large prime number
#1536 bit prime number - http://www.ietf.org/rfc/rfc3526.txt
prime = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF

#associated generator number - http://www.ietf.org/rfc/rfc3526.txt
gen = 2



def gen_public_transport(encrypt_protocol=False, long_term_key=0, auth_arr=[]):
    '''
    generates a tuple containing the data to pass to the other computer, 
    aka the public_transport, as well as the local-exponent which will
    be required later on to generate the session-key.
    
    Arguments:
    encrypt_protocol - a bool, which if set to True,
    utilizes long_term_key to encrypt the data that comprises the public_transport
    long_term_key - key used in aes encryption
    auth_arr - if present, is used as per the authentication DH scheme
               that is, it's prepended to the proper public_transport
               before encryption.
    
    Returns: tuple(public_transport, local_exponent)      
    '''
    if debug:
        print("generating public transport data")
    
    local_exponent = random.getrandbits(128)
    if debug:
        print("local_exponent: " + str(local_exponent))
    
    pub_transport = pow(gen, local_exponent, prime)
    if debug:
        print("pub_transport:" + str(pub_transport))
        
    if encrypt_protocol == False:
        return (pub_transport, local_exponent)
    else:
        #pub_transport is an array of bytes, if encrypted
        if not auth_arr:
            pub_transport = aes.aes_encrypt(intToByteArray(pub_transport), long_term_key)
            if debug:
                print("public_transport, encrypted: " + str(pub_transport))
            return (pub_transport, local_exponent)
        else:
            # If performing encrypted authorization, encrypt the public_transport
            # with the authorization_array (the ID and nonce) prepended to 
            # the transport data
            print("Generating pub transport, with auth_arr")
            pub_transport_arr = intToByteArray(pub_transport)
                
            pub_transport = list(auth_arr) + list(pub_transport_arr)
            pub_transport = aes.aes_encrypt(pub_transport, long_term_key)
            if debug:
                print("public_transport, encrypted: " + str(pub_transport))
            return (pub_transport, local_exponent)

def gen_session_key(inc_pub_transport, local_exponent, encrypt_protocol=False, long_term_key=0, auth_arr=[]):
    '''
    generates a session key
    
    Arguments:
    inc_pub_transport - The value of the public_transport generated by a different
    computer, incoming.
    local_exponent - Secret value computed by gen_public_transport, used to combine
    with the inc_pub_transport to generate the session_key
    encrypt_protocol - Bool stating whether or not the inc_pub_transport needs
    to be decrypted before being used to generate the session_key.
    long_term_key - key used for aes decryption if encrypt_protocol set True
    auth_arr - Present if performing authentication, therefore including 
                     data/nonce in decryption data. This array is used 
                     as comparison with the received array to authenticate.
    
    returns:
    unique session key (only known to client/server), or 0 if using auth_arr,
    and data not authenticated
    '''
    if encrypt_protocol == True:
        inc_pub_transport_bytes = aes.aes_decrypt(inc_pub_transport, long_term_key)
        
        if auth_arr:
            inc_auth_arr = inc_pub_transport_bytes[:20] 
            for inc_byte,auth_byte in zip(inc_auth_arr, auth_arr):
                if not inc_byte == auth_byte:
                    print("Not authenticated.")
                    return 0
                
            # reduce bytes to actual data
            inc_pub_transport_bytes = inc_pub_transport_bytes[20:] 
        
        inc_pub_transport = byteArrayToInt(inc_pub_transport_bytes)
    
    session_key = pow(inc_pub_transport, local_exponent, prime)
    
    session_key = intToByteArray(session_key)[:16] #get first 16 bytes, so that key corresponds to a true aes key.
    
    if debug:
        print("private session key is: " + str(session_key))
    
    return session_key

def gen_nonce():
    '''
    generates a nonce
    
    Returns: 16 byte nonce represented in byte array.      
    '''
    return list(intToByteArray(random.getrandbits(128), 16))

def gen_auth_msg(nonce_array = []):
    '''
    generates a tuple containing the 1st of 3 messages to be sent in the 
    Authenticated Diffie Hellmen exchange
    
    Arguments:
    Optionally supply a nonce_array, which if supplied will be
    used in the returned array, rather than generating a new one.
    Basically use this parameter to append the ID to the nonce.
    
    Returns: 20 bytes starting with 4: id of self - IP, 
                      followed with 16: bytearray nonce      
    '''
    ip_array = [int(byte) for byte in connector.get_ip().split('.')]
    if not nonce_array:
        nonce_array = [int(byte) for byte in gen_nonce()]
    
    return list(ip_array) + list(nonce_array)

def intToByteArray(inputInt, forced_len=-1):
    '''
    converts arbitrarily long integer into array of bytes
    
    Arguments:
    inputInt - arbitrarily long int
    forced_len - specify length of array, buffered with 0s by default
    
    Returns:
    bytearray representative of inputInt 
    '''
    int_bytes = bytearray()
    idx = 0
    while inputInt > 0:
        int_bytes.append(inputInt % 256)
        inputInt = inputInt // 256        
        idx += 1
        if forced_len > 0:
            if len(int_bytes) >= forced_len:
                break
  
    if forced_len > 0 and len(int_bytes) < forced_len:
        while len(int_bytes) < forced_len:
            int_bytes.insert(0, 0)
    
    #for byte in int_bytes:
    #    print("byte: " + str(byte))        
    #print(str(int_bytes))
       
    return int_bytes


def byteArrayToInt(int_bytes):
    '''
    converts array of bytes into arbitrarily long integer 
    
    Arguments:
    int_bytes - bytearray representative of inputInt
    
    Returns:
    arbitrarily long int
    '''
    ret_int = 0
    
    while(len(int_bytes) > 0):
        ret_int = ret_int*256 + int_bytes.pop()
        
    return ret_int
        
        
      
    
def run_test():
    #Jorden Testing:
    
    # Test basic functionality.  -- PASSES
    data1 = gen_public_transport()
    data2 = gen_public_transport()
    
    s1 = gen_session_key(data1[PUB_TRANSPORT_IDX], data2[LOC_EXPONENT_IDX])
    s2 = gen_session_key(data2[PUB_TRANSPORT_IDX], data1[LOC_EXPONENT_IDX])
    
    if s1 == s2:
        print("Test 1: Thank god, dh works with non-encrypted data passing\n" + str(data1) + "\n" + str(s1) + "\n" + str(s2) + "\n")
    else:
        print("Test 1: Oh no, something terrible has gone wrong with dh\n" + str(data1) + "\n" + str(s1) + "\n" + str(s2) + "\n")

    # Test encrypted key exchange, to implement PFS properly. -- PASSES
    long_term_key = "abcdefghijklmnop"
    
    data1 = gen_public_transport(True, long_term_key)
    data2 = gen_public_transport(True, long_term_key)
    
    s1 = gen_session_key(data1[PUB_TRANSPORT_IDX], data2[LOC_EXPONENT_IDX], True, long_term_key)
    s2 = gen_session_key(data2[PUB_TRANSPORT_IDX], data1[LOC_EXPONENT_IDX], True, long_term_key)
    
    # for PFS, must forget the values used to generate session_keys
    # AKA "ephemeral Diffie-Hellman key exchange"
    data1 = (0, 0)
    data2 = (0, 0)
    
    if s1 == s2:
        print("Test 2: Thank god, dh works with encrypted message passing\n" + str(data1) + "\n" + str(s1) + "\n" + str(s2) + "\n")
    else:
        print("Test 2: Oh no, something terrible has gone wrong with dh\n" + str(data1) + "\n" + str(s1) + "\n" + str(s2) + "\n")
    
    if data1 == (0,0) and data2 == (0,0):
        print("Test 3: Passed; temporary local-exponents used to generate session key have been destroyed \nPFS is in place.")
    else:
        print("Test 3: Failed; PFS failure. Investigate dh.py")
        
    '''    
    print("***Starting Test 4***")
    #Alice does this
    client_init_msg = gen_auth_msg() # "Im Alice" - SEND THIS
    client_init_msg[:4] = [1,1,1,1] #Override ID since just a basic test
    
    #Bob does this after recieving init_msg
    print("*********************************************")
    client_id = client_init_msg[:4]
    client_nonce = client_init_msg[4:]
    print("Bob recieved id: " + str(client_id) + ", and nonce: " + str(client_nonce)) 
    # then generates a resonse
    server_nonce = gen_nonce()
    server_auth_msg = gen_auth_msg(client_nonce)
    server_auth_msg[:4] = [2,2,2,2] #Override ID since just a basic test
    print("Bob auth msg: " + str(server_auth_msg))
    server_encrypted_msg =  gen_public_transport(True, long_term_key, server_auth_msg)
    server_public_transport = server_nonce + server_encrypted_msg[PUB_TRANSPORT_IDX] # Bob SENDS THIS
    print("Bob public transport: " + str(server_public_transport))
    
    #Alice then does this with the incoming transport
    print("*********************************************")
    rcv_server_nonce = server_public_transport[:16]
    rcv_server_public_transport = server_public_transport[16:]
    print("Alice rcv server nonce: " + str(rcv_server_nonce))
    client_auth_msg = gen_auth_msg(rcv_server_nonce)
    client_auth_msg[:4] = [1,1,1,1] #Override ID since just a basic test
    print("Alice auth msg: " + str(client_auth_msg))
    client_encrypted_msg = gen_public_transport(True, long_term_key, client_auth_msg)
    client_public_transport = client_encrypted_msg[PUB_TRANSPORT_IDX] #Alice SENDS THIS
 
    # Then each party authenticates and gets the DH public_transport data to compute
    # the session key.
    
    # Bob does this:
    print("*********************************************")
    expected_auth_msg = client_id + server_nonce 
    print("Bob expects auth msg: " + str(expected_auth_msg))
    server_key = gen_session_key(client_public_transport, server_encrypted_msg[LOC_EXPONENT_IDX], True, long_term_key, expected_auth_msg)
    print("Server session key: " + str(server_key))
    #Alice does this:
    # compare against Bob's ID and Alice's nonce:
    print("*********************************************")
    # BOB_ID = self.getIPFromTextBox - that's what alice actually cares about.
    BOB_ID = [2,2,2,2] #[int(byte) for byte in connector.get_ip().split('.')] #TEMP - not correct code to be used. - should be as line above.
    expected_auth_msg = BOB_ID + client_init_msg[4:]
    print("Alice expects auth msg: " + str(expected_auth_msg))
    client_key = gen_session_key(rcv_server_public_transport, client_encrypted_msg[LOC_EXPONENT_IDX], True, long_term_key, expected_auth_msg)
    print("Client session key: " + str(client_key))
    
    if client_key == server_key:
        print("Test 4 passed!! Yayy")
    else:
        print("Test 4 Failed. BOOOO :(")
    ''' 
    
    
    print("*********************************************")
    print("*********************************************")
    print("*********************************************")
    print("Test 5")
    #Alice does this
    client_init_msg = gen_auth_msg() # "Im Alice" - SEND THIS
    
    #Bob does this after recieving init_msg
    print("*********************************************")
    client_id = client_init_msg[:4]
    client_nonce = client_init_msg[4:]
    print("Bob recieved id: " + str(client_id) + ", and nonce: " + str(client_nonce))
    # then generates a resonse
    server_nonce = gen_nonce()
    server_auth_msg = gen_auth_msg(client_nonce)
    print("Bob auth msg: " + str(server_auth_msg))
    server_encrypted_msg =  gen_public_transport(True, long_term_key, server_auth_msg)
    server_public_transport = server_nonce + server_encrypted_msg[PUB_TRANSPORT_IDX] # Bob SENDS THIS
    print("Bob public transport: " + str(server_public_transport))
    
    #Alice then does this with the incoming transport
    print("*********************************************")
    rcv_server_nonce = server_public_transport[:16]
    rcv_server_public_transport = server_public_transport[16:] 
    client_auth_msg = gen_auth_msg(rcv_server_nonce)
    client_encrypted_msg = gen_public_transport(True, long_term_key, client_auth_msg)
    client_public_transport = client_encrypted_msg[PUB_TRANSPORT_IDX] #Alice SENDS THIS
 
    # Then each party authenticates and gets the DH public_transport data to compute
    # the session key.
    
    # Bob does this:
    print("*********************************************")
    expected_auth_msg = client_id + server_nonce 
    print("Bob expects auth msg: " + str(expected_auth_msg))
    server_key = gen_session_key(client_public_transport, server_encrypted_msg[LOC_EXPONENT_IDX], True, long_term_key, expected_auth_msg)
    print("Server session key: " + str(server_key))
    #Alice does this:
    # compare against Bob's ID and Alice's nonce:
    print("*********************************************")
    # BOB_ID = self.getIPFromTextBox - that's what alice actually cares about.
    BOB_ID = [int(byte) for byte in connector.get_ip().split('.')] #TEMP - not correct code to be used. - should be as line above.
    expected_auth_msg = BOB_ID + client_init_msg[4:]
    print("Alice expects auth msg: " + str(expected_auth_msg))
    client_key = gen_session_key(rcv_server_public_transport, client_encrypted_msg[LOC_EXPONENT_IDX], True, long_term_key, expected_auth_msg)
    print("Client session key: " + str(client_key))
        
    if client_key == server_key:
        print("Test 5 passed!! Yayy")
    else:
        print("Test 5 Failed. BOOOO :(")
    
    return
  
if __name__ == '__main__':
    run_test()

#arr = connector.get_ip().split('.')
#arr2 = [int(byte) for byte in connector.get_ip().split('.')]

#print(str(arr2))
#print(str(gen_initial_client_auth_msg()))


