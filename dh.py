"""This module contains an implementation of the Deffie-Hellman 
Key Exchange Protocol.

Functions:
def gen_public_transport(encrypt_protocol=False, long_term_key=0)
-- used to generate local data, some of which should be sent as the transport data
gen_session_key(inc_pub_transport, local_exponent, encrypt_protocol=False, long_term_key=0)
-- used with the incoming transport data to generate a session key, only known
        locally, and to the computer that sent the transport data
"""
from _collections_abc import ByteString

debug = False

import random
import aes

PUB_TRANSPORT_IDX = 0
LOC_EXPONENT_IDX = 1

#public large prime number
#1536 bit prime number - http://www.ietf.org/rfc/rfc3526.txt
prime = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF

#associated generator number - http://www.ietf.org/rfc/rfc3526.txt
gen = 2

def gen_public_transport(encrypt_protocol=False, long_term_key=0):
    '''
    generates a tuple containing the data to pass to the other computer, 
    aka the public_transport, as well as the local-exponent which will
    be required later on to generate the session-key.
    
    Arguments:
    encrypt_protocol - a bool, which if set to True,
    utilizes long_term_key to encrypt the data that comprises the public_transport
    long_term_key - key used in aes encryption
    
    Returns: tuple(public_transport, local_exponent)      
    '''
    if debug:
        print("generating public transport data")
    
    local_exponent = random.getrandbits(128)
    if debug:
        print("local_exponent: " + str(local_exponent))
    
    pub_transport = pow(gen, local_exponent, prime)
    if debug:
        print("pub_transport:" + str(pub_transport))
        
    if encrypt_protocol == False:
        #pub_transport is an int, convert to a bytestring
        return (bytes(str(pub_transport)), local_exponent)
    else:
        #pub_transport is an array of bytes
        pub_transport = aes.aes_encrypt(intToByteArray(pub_transport), long_term_key)
        if debug:
            print("public_transport, encrypted: " + str(pub_transport))
        return (pub_transport, local_exponent)

def gen_session_key(inc_pub_transport, local_exponent, encrypt_protocol=False, long_term_key=0):
    '''
    generates a session key
    
    Arguments:
    inc_pub_transport - The value of the public_transport generated by a different
    computer, incoming.
    local_exponent - Secret value computed by gen_public_transport, used to combine
    with the inc_pub_transport to generate the session_key
    encrypt_protocol - Bool stating whether or not the inc_pub_transport needs
    to be decrypted before being used to generate the session_key.
    long_term_key - key used for aes decryption if encrypt_protocol set True
    
    returns:
    unique session key (only known to client/server)
    '''
    if encrypt_protocol == True:
        inc_pub_transport_bytes = aes.aes_decrypt(inc_pub_transport, long_term_key) #JHH This needs attention, as it comes back as a list of bytes
        inc_pub_transport = byteArrayToInt(inc_pub_transport_bytes)
    
    session_key = pow(inc_pub_transport, local_exponent, prime)
    
    session_key = intToByteArray(session_key)[:16] #get first 16 bytes, so that key corresponds to a true aes key.
    
    if debug:
        print("private session key is: " + str(session_key))
    
    return session_key

def intToByteArray(inputInt):
    '''
    converts arbitrarily long integer into array of bytes
    
    Arguments:
    inputInt - arbitrarily long int
    
    Returns:
    bytearray representative of inputInt 
    '''
    int_bytes = bytearray()
    idx = 0
    while inputInt > 0:
        int_bytes.append(inputInt % 256)
        inputInt = inputInt // 256        
        idx += 1
    #print(str(int_bytes))
       
    return int_bytes


def byteArrayToInt(int_bytes):
    '''
    converts array of bytes into arbitrarily long integer 
    
    Arguments:
    int_bytes - bytearray representative of inputInt
    
    Returns:
    arbitrarily long int
    '''
    ret_int = 0
    
    while(len(int_bytes) > 0):
        ret_int = ret_int*256 + int_bytes.pop()
        
    return ret_int
        
        
      
    
def run_test():
    #Jorden Testing:
    
    # Test basic functionality.  -- PASSES
    data1 = gen_public_transport()
    data2 = gen_public_transport()
    
    s1 = gen_session_key(data1[PUB_TRANSPORT_IDX], data2[LOC_EXPONENT_IDX])
    s2 = gen_session_key(data2[PUB_TRANSPORT_IDX], data1[LOC_EXPONENT_IDX])
    
    if s1 == s2:
        print("Test 1: Thank god, dh works with non-encrypted data passing\n" + str(data1) + "\n" + str(s1) + "\n" + str(s2) + "\n")
    else:
        print("Test 1: Oh no, something terrible has gone wrong with dh\n" + str(data1) + "\n" + str(s1) + "\n" + str(s2) + "\n")

    # Test encrypted key exchange, to implement PFS properly. -- PASSES
    long_term_key = "abcdefghijklmnop"
    
    data1 = gen_public_transport(True, long_term_key)
    data2 = gen_public_transport(True, long_term_key)
    
    s1 = gen_session_key(data1[PUB_TRANSPORT_IDX], data2[LOC_EXPONENT_IDX], True, long_term_key)
    s2 = gen_session_key(data2[PUB_TRANSPORT_IDX], data1[LOC_EXPONENT_IDX], True, long_term_key)
    
    # for PFS, must forget the values used to generate session_keys
    # AKA "ephemeral Diffie-Hellman key exchange"
    data1 = (0, 0)
    data2 = (0, 0)
    
    if s1 == s2:
        print("Test 2: Thank god, dh works with encrypted message passing\n" + str(data1) + "\n" + str(s1) + "\n" + str(s2) + "\n")
    else:
        print("Test 2: Oh no, something terrible has gone wrong with dh\n" + str(data1) + "\n" + str(s1) + "\n" + str(s2) + "\n")
    
    if data1 == (0,0) and data2 == (0,0):
        print("Test 3: Passed; temporary local-exponents used to generate session key have been destroyed \nPFS is in place.")
    else:
        print("Test 3: Failed; PFS failure. Investigate dh.py")
    return
    

test_int = 12345

print(test_int.to_bytes(5))
  
#run_test()




