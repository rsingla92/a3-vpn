"""This module contains an implementation of the Deffie-Hellman
Key Exchange Protocol.

Functions:
def gen_public_transport(encrypt_protocol=False, long_term_key=0)
-- used to generate local data, some of which should be sent as the transport data
gen_session_key(inc_pub_transport, local_exponent, encrypt_protocol=False, long_term_key=0)
-- used with the incoming transport data to generate a session key, only known
        locally, and to the computer that sent the transport data
"""
import random
import aes
import connector

debug = False

PUB_TRANSPORT_IDX = 0
LOC_EXPONENT_IDX = 1

#public large prime number
#1536 bit prime number - http://www.ietf.org/rfc/rfc3526.txt
prime = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF

#associated generator number - http://www.ietf.org/rfc/rfc3526.txt
gen = 2


def gen_public_transport(long_term_key, auth_arr):
    """
    generates a tuple containing the data to pass to the other computer,
    aka the public_transport, as well as the local-exponent which will
    be required later on to generate the session-key.

    Arguments:
    long_term_key - key used in aes encryption
    auth_arr - if present, is used as per the authentication DH scheme
               that is, it's prepended to the proper public_transport
               before encryption.

    Returns: tuple(public_transport, local_exponent)
    """
    if debug:
        print("generating public transport data")

    local_exponent, pub_transport, pub_transport_arr = None, None, None
    while True:
        local_exponent = random.getrandbits(128)
        if debug:
            print("local_exponent: " + str(local_exponent))

        pub_transport = pow(gen, local_exponent, prime)
        if debug:
            print("pub_transport:" + str(pub_transport))

        # -pub_transport is an array of bytes, if encrypted
        # -Encrypt the public_transport
        # with the authorization_array (the ID and nonce) prepended to
        # the transport data
        pub_transport_arr = int_to_byte_array(pub_transport)
        if pub_transport_arr[-1] != 128:
            # We are okay as long as the last byte is not the same as the padding byte
            # for AES. Otherwise it will be stripped. If it is 128, continue generating
            # local exponents until it is not.
            break;

    pub_transport = list(auth_arr) + list(pub_transport_arr)
    print("generating public transport - public transport: " + str(pub_transport))
    pub_transport = aes.aes_encrypt(pub_transport, long_term_key)
    if debug:
        print("public_transport, encrypted: " + str(pub_transport))
    return pub_transport, local_exponent

def gen_session_key(inc_pub_transport, local_exponent, long_term_key, auth_arr):
    """
    generates a session key

    Arguments:
    inc_pub_transport - The value of the public_transport generated by a different
    computer, incoming.
    local_exponent - Secret value computed by gen_public_transport, used to combine
    with the inc_pub_transport to generate the session_key
    long_term_key - key used for aes decryption if encrypt_protocol set True
    auth_arr - To perform authentication, therefore including
                     data/nonce in decryption data. This array is used
                     as comparison with the received array to authenticate.

    returns:
    unique session key (only known to client/server), or 0 if using auth_arr,
    and data not authenticated
    """
    inc_pub_transport_bytes = aes.aes_decrypt(inc_pub_transport, long_term_key)
    print("generating session key - public transport: " + str(inc_pub_transport_bytes))
    inc_auth_arr = inc_pub_transport_bytes[:20]
    for inc_byte,auth_byte in zip(inc_auth_arr, auth_arr):
        if not inc_byte == auth_byte:
            print("Not authenticated.")
            return 0

    # reduce bytes to actual data
    inc_pub_transport_bytes = inc_pub_transport_bytes[20:]

    inc_pub_transport = byte_array_to_int(inc_pub_transport_bytes)

    session_key = pow(inc_pub_transport, local_exponent, prime)

    # get first 16 bytes, so that key corresponds to a true aes key.
    session_key = int_to_byte_array(session_key)[:16]

    if debug:
        print("private session key is: " + str(session_key))

    return session_key

def gen_nonce():
    """
    generates a nonce and prevents the last byte from being the padding bit used in
    the aes encryption (128)

    Returns: 16 byte nonce represented in byte array.
    """
    nonce = list(int_to_byte_array(random.getrandbits(128), 16))
    while nonce[-1] == 128:
        nonce[-1] = random.getrandbits(8)
    return nonce

def gen_auth_msg(nonce_array=[]):
    """
    generates a tuple containing the 1st of 3 messages to be sent in the
    Authenticated Diffie Hellmen exchange

    Arguments:
    Optionally supply a nonce_array, which if supplied will be
    used in the returned array, rather than generating a new one. If you
    supply a nonce, the last byte cannot be the padding character in aes, 128.
    Basically use this parameter to append the ID to the nonce.

    Returns: 20 bytes starting with 4: id of self - IP,
                      followed with 16: bytearray nonce
    """
    ip_array = [int(byte) for byte in connector.get_ip().split('.')]
    if len(nonce_array) == 0:
        nonce_array = [int(byte) for byte in gen_nonce()]

    return list(ip_array) + list(nonce_array)

def int_to_byte_array(input_int, forced_len=-1):
    """
    converts arbitrarily long integer into array of bytes

    Arguments:
    inputInt - arbitrarily long int
    forced_len - specify length of array, buffered with 0s by default

    Returns:
    bytearray representative of inputInt
    """
    int_bytes = bytearray()
    idx = 0
    while input_int > 0:
        int_bytes.append(input_int % 256)
        input_int = input_int // 256
        idx += 1
        if forced_len > 0:
            if len(int_bytes) >= forced_len:
                break

    if forced_len > 0 and len(int_bytes) < forced_len:
        while len(int_bytes) < forced_len:
            int_bytes.append(0)

    int_bytes.reverse()
    return int_bytes


def byte_array_to_int(int_bytes):
    """
    converts array of bytes into arbitrarily long integer

    Arguments:
    int_bytes - bytearray representative of inputInt

    Returns:
    arbitrarily long int
    """
    ret_int = 0
    place = 1
    while(len(int_bytes) > 0):
        ret_int += int_bytes.pop() * place
        place *= 256

    return ret_int

def run_test():
    #Jorden Testing:
    long_term_key = "abcdefghijklmnop"

    print("*********************************************")
    print("Test Full DH With Authentication")
    #Alice does this
    client_init_msg = gen_auth_msg() # "Im Alice" - SEND THIS

    #Override ID since just a basic test
    client_init_msg[:4] = [1,1,1,1]
    print("1st Message Sent = " + str(client_init_msg))

    #Bob does this after receiving init_msg
    print("*********************************************")
    client_id = client_init_msg[:4]
    client_nonce = client_init_msg[4:]
    print("Bob received id: " + str(client_id) + ", and nonce: " + str(client_nonce))
    # then generates a response
    server_nonce = gen_nonce()
    print("Bob nonce: " + str(server_nonce))
    server_auth_msg = gen_auth_msg(client_nonce)
    # Override ID since just a basic test
    server_auth_msg[:4] = [2,2,2,2]
    print("Bob auth msg: " + str(server_auth_msg))
    server_encrypted_msg = gen_public_transport(long_term_key, server_auth_msg)
    server_public_transport = server_nonce + server_encrypted_msg[PUB_TRANSPORT_IDX] # Bob SENDS THIS
    print("2nd Message Sent - Bob public transport: " + str(server_public_transport))

    #Alice then does this with the incoming transport
    print("*********************************************")
    rcv_server_nonce = server_public_transport[:16]
    assert(server_nonce == rcv_server_nonce)
    rcv_server_public_transport = server_public_transport[16:]
    assert(server_public_transport[16:] == rcv_server_public_transport)
    client_auth_msg = gen_auth_msg(rcv_server_nonce)
    # Override ID since just a basic test
    client_auth_msg[:4] = [1,1,1,1]
    client_encrypted_msg = gen_public_transport(long_term_key, client_auth_msg)
    client_public_transport = client_encrypted_msg[PUB_TRANSPORT_IDX] #Alice SENDS THIS
    print("3rd Message Sent - Alice public transport" + str(client_public_transport))

    # Then each party authenticates and gets the DH public_transport data to compute
    # the session key.
    # Bob does this:
    print("*********************************************")
    expected_auth_msg = client_id + server_nonce
    print("Bob expects auth msg: " + str(expected_auth_msg))
    server_key = gen_session_key(client_public_transport, server_encrypted_msg[LOC_EXPONENT_IDX], long_term_key, expected_auth_msg)
    print("Server session key: " + str(server_key))
    #Alice does this:
    # compare against Bob's ID and Alice's nonce:
    print("*********************************************")
    # BOB_ID = self.getIPFromTextBox - that's what alice actually cares about.
    bob_id = [2,2,2,2] #Tempppp [int(byte) for byte in connector.get_ip().split('.')] #TEMP - not correct code to be used. - should be as line above.
    expected_auth_msg = bob_id + client_init_msg[4:]
    print("Alice expects auth msg: " + str(expected_auth_msg))
    client_key = gen_session_key(rcv_server_public_transport, client_encrypted_msg[LOC_EXPONENT_IDX], long_term_key, expected_auth_msg)
    print("Client session key: " + str(client_key))

    if client_key == server_key:
        print("Test passed!! Yayy")
    else:
        print("Test Failed. BOOOO :(")

    return

if __name__ == '__main__':
    run_test()




